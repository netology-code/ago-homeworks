# Домашнее задание к занятию «3.2 Микросервисы: Synchronous Communication»

Все задачи этого занятия можно делать в **одном репозитории**.

В качестве результата пришлите ссылки на ваши GitHub-проекты через личный кабинет студента на сайте [netology.ru](https://netology.ru).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

## Как сдавать задачи

1. Создайте на вашем компьютере проект, в котором разместите Go-модули (на основании исходников с лекции).
1. Инициализируйте в нём пустой Git-репозиторий.
1. Добавьте в него готовый файл [.gitignore](../.gitignore).
1. Сделайте необходимые коммиты.
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым.
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub).
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru).
1. Задачи, отмеченные как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными).

## Upgrade to gRPC

### Задача

На лекции мы реализовали микросервисы, "используя" REST в качестве коммуникации между ними.

Что нужно сделать: замените коммуникации между сервисом Backend и сервисом Transactions на gRPC. Используйте [готовый код с лекции](https://github.com/netology-code/ago-code/tree/ago2/10_micro-sync).

<details>
<summary>Описание изменений</summary>

Для этого вам нужно:

1\. В `transactions.Service` Backend'а использовать gRPC клиент вместо http.Client:
```go
type Service struct {
	client *http.Client // заменить на сгенерированный клиент
	url    string
}
```
2\. В Transactions заменить REST-сервер на gRPC-сервер:
```go
mux := chi.NewRouter()

application := app.NewServer(transactionsSvc, mux)
err = application.Init()
if err != nil {
    log.Print(err)
    return err
}

server := &http.Server{
    Addr:    addr,
    Handler: application,
}
return server.ListenAndServe()
```

Воспользуйтесь [кодом с лекции по gRPC](https://github.com/netology-code/ago-code/tree/ago2/07_grpc/insecure), используя Unary сообщения. `UserId` передавайте как поле в сообщении.
```protobuf
message TransactionsRequest { // запрос
  string userId = 1;
}
```

Полученный ответ вы можете сериализовать в JSON с помощью `json.Marshal`, т.к. при генерации из `.proto` за вас автоматически добавят необходимые теги `json` в структуру, получаемую из `Message`.
</details>

**Важно**: важно заменить только интерфейс коммуникации, другие данные менять не нужно.

Сгенерированные в результате работы `protoc`-файлы также должны присутствовать в Git-репозитории.

Удостоверьтесь, что после замены интерфейса, клиент, написанный на лекции, по-прежнему работает.

### Результаты

В качестве результата пришлите ссылку на ваш GitHub-проект, в котором реализованы описанные выше требования.
