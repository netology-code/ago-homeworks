# Домашнее задание к занятию «2.4 gRPC (часть 2)»

Все задачи этого занятия можно делать в **одном репозитории**.

В качестве результата пришлите ссылки на ваши GitHub-проекты через личный кабинет студента на сайте [netology.ru](https://netology.ru).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции).
1. Добавьте в него в качестве зависимостей pgx и всё, что нужно для создания gRPC сервера и клиента.
1. Инициализируйте в нём пустой Git-репозиторий.
1. Добавьте в него готовый файл [.gitignore](../.gitignore).
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам).
1. Сделайте необходимые коммиты.
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым.
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub).
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru).
1. Задачи, отмеченные как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными).

## Мини-проект Aggregator*

**Важно**: это не обязательная задача (выполняйте её по желанию). Обратите внимание, что на её выполнение может уйти достаточно много времени.

### Легенда

<details>
<summary>Легенда</summary>

В наше время достаточно популярны так называемые агрегаторы - т.е. сервисы, которые занимаются сбором предложений с других сервисов, а иногда и продают доп.услуги, в виде сопровождения, страхования и т.д.

Тинькофф предоставляет сервис Путешествия, на котором в числе прочего можно приобрести авиабилеты:

![](pic/aggregator.png)

Что на этом сервисе интересно? Если вы вобьёте данные для поиска, то увидите, что данные подгружаются не единоразово, а "догружаются в процессе":

![](pic/aviasales.png)

Соответственно, мы хотим сделать примерно такую же вещь средствами gRPC: у нас будет клиент и сервер, предоставляющий метод типа Server Stream.

</details>

### Задача

Реализуйте gRPC-сервер и gRPC-клиент в одном проекте (для них должны быть разные бинарники, формируемые из `cmd`), реализующие функциональность поиска с возвратом результатов в виде Server Stream.

Параметры запроса:
* дата
* город вылета
* город прилёта

О других данных можете не думать. CRUD реализовывать не надо, нужно реализовать обработку одного запроса - поиск.

Каждое возвращаемое предложение должно содержать следующие данные:
* id
* время вылета
* время в пути
* стоимость

Сервис поиска должен собирать данные с других сервисов и выдавать их по мере получения в stream.

<details>
<summary>Эмуляция сбора данных</summary>

**Q**: как эмулировать сбор данных с разных сервисов?

**A**: мы предлагаем вам создать три сервиса, например, `First`, `Second`, `Third`, где просто в `map` (или любой удобной для вас структуре) будут храниться данные. Тогда в вашем основном сервисе будет:

```go
type Service struct {
    firstSvc *stub.Service
    secondSvc *stub.Service
    thirdSvc *stub.Service
}
```

Примечание*: `stub` переводится как заглушка.

А в сервисах метод будет:
```go
func (s *Service) Search(date <ваш тип>, from, to string) []*Result {
    // TODO: sleep с рандомной задержкой
}
```

Данные можете как захардкодить, так и вычитывать из JSON или базы данных.
</details>

Когда вам от клиента приходит запрос, вы запускаете три горутины, каждая из которых ищет в своём сервисе, а результаты скидывает в stream ответа.

**Важно**: посылать данные в stream безопасно можно только из одной горутины (также, как и читать их). Поэтому вам нужно использовать соответствующие механизмы (например, каналы).

Итого:
1. Вы пишете `.proto`-файлы, описывающие требуемые операции, типы сообщений - на ваше усмотрение (в соответствии с ДЗ)
1. Вы генерируете на основании `.proto` файлы `*.pb.go`, содержащие интерфейсы для клиента и сервера
1. Вы пишете реализацию сервера - `cmd/avia/server`
1. Вы пишете реализацию клиента - `cmd/avia/client` с демонстрацией запроса поиска и вывода результатов (нужен всего один запрос)

Сгенерированные в результате работы `protoc`-файлы также должны присутствовать в Git-репозитории, как и `docker-compose.yml` и демо-данные для проверки (`docker-entrypoint-initdb.d` - всё, как проходили).

В качестве результата пришлите ссылку на ваш GitHub-проект, в котором реализованы описанные выше требования.
